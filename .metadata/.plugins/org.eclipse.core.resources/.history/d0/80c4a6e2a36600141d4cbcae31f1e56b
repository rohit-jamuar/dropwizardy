package com.dropwizard_application.resources;

import java.util.HashMap;

import io.dropwizard.hibernate.UnitOfWork;

import com.dropwizard_application.core.HashedStringRepresentation;
import com.dropwizard_application.dB.InputOutput;
import com.dropwizard_application.dB.InputOutputDAO;
import com.google.common.base.Optional;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;
import javax.ws.rs.Produces;
import javax.ws.rs.QueryParam;
import javax.ws.rs.core.MediaType;

@Path("/getHash")
@Produces(MediaType.APPLICATION_JSON)
public class CipherResource {

	private final InputOutputDAO d;
	private static HashMap<Integer, Character> reverseCharMappings = new HashMap<Integer, Character>();
	private static HashMap<Character, Integer> charMappings = new HashMap<Character, Integer>();
	
	public CipherResource(InputOutputDAO d) { 
		if (reverseCharMappings.isEmpty() || charMappings.isEmpty())
		{
			char[] characters = "abcdefghijklmnopqrstuvwxyz".toCharArray();
			for (int i = 0; i<characters.length; i++)
			{
				reverseCharMappings.put(i, characters[i]);
				charMappings.put(characters[i], i);
			}
		}
		this.d = d;
	}
	
	private String generateCeaserCipher(String s, int key)
	{
		int newIndex;
		StringBuilder result = new StringBuilder();
		for (int i=0; i<s.length(); i++)
		{
			char currentChar = s.charAt(i);
			if ('a' >= currentChar &&  currentChar <= 'z')
			{
				newIndex = (charMappings.get(currentChar) + key) % reverseCharMappings.size();
				result.append(reverseCharMappings.get(newIndex));
			}
			if ('A' >= currentChar &&  currentChar <= 'Z')
			{
				newIndex = (charMappings.get(Character.toLowerCase(currentChar)) + key) % reverseCharMappings.size();
				result.append(Character.toUpperCase(reverseCharMappings.get(newIndex)));
			}
			else
			{
				result.append(currentChar);
			}
		}
		return result.toString();
	}
	
	@GET
	@UnitOfWork
	public HashedStringRepresentation getCipher(@QueryParam("str") Optional<String> str)
	{
		String strPassed = str.or("Stranger");
		String cipherProduced = generateCeaserCipher(strPassed, 5);
		d.create(new InputOutput(strPassed, cipherProduced));
		return new HashedStringRepresentation(strPassed, cipherProduced);
	}
	
}